From: "Saved by Internet Explorer 11"
Subject: Christoph Schwarzweller: Scheme
Date: Fri, 13 Nov 2015 12:06:55 +0100
MIME-Version: 1.0
Content-Type: text/html;
	charset="Windows-1252"
Content-Transfer-Encoding: quoted-printable
Content-Location: https://inf.ug.edu.pl/~schwarzw/zadania/ZadScheme2015.html
X-MimeOLE: Produced By Microsoft MimeOLE V10.0.10011.16384

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><META content=3D"IE=3D5.0000" =
http-equiv=3D"X-UA-Compatible">
<TITLE>Christoph Schwarzweller: Scheme</TITLE>=20
<META http-equiv=3D"Content-Type" content=3D"text/html; =
charset=3Dwindows-1252"><LINK=20
href=3D"../cs.css" rel=3D"stylesheet" type=3D"text/css">=20
<META name=3D"GENERATOR" content=3D"MSHTML 11.00.10240.16566"></HEAD>=20
<BODY class=3D"main"><BR>
<H2> Zadania (Scheme) </H2>
<OL>
  <LI>  Jakie s&#261; warto&#347;ci nast&#281;puj&#261;cych =
wyra&#380;e&#324;? <BR><BR>
<PRE>=3D=3D&gt; 10 <BR><BR>=0A=
=3D=3D&gt; (+ 5 3 4) <BR><BR>=0A=
=3D=3D&gt; (- 9 1) <BR><BR>=0A=
=3D=3D&gt; (/ 6 2) <BR><BR>=0A=
=3D=3D&gt; (+ ( * 2 4) (- 4 6)) <BR><BR>=0A=
=3D=3D&gt; (let ((a 1) (b 2)) (+ a b (* a b))) <BR><BR>=0A=
=3D=3D&gt; a <BR><BR>=0A=
=3D=3D&gt; (define a 3) <BR><BR>=0A=
=3D=3D&gt; (define b (+ a 1)) <BR><BR>=0A=
=3D=3D&gt; (+ a b (* a b)) <BR><BR>=0A=
=3D=3D&gt; (=3D a b) <BR><BR>=0A=
=3D=3D&gt; (if (and (&gt; b a) (&lt; b (* a b))) =0A=
        b =0A=
        a) <BR><BR>=0A=
=3D=3D&gt; (cond ((=3D a 4) 6) =0A=
          ((=3D b 4) (+ 6 7 a))=0A=
          (else    25))=0A=
</PRE>
  <LI>  Prosz&#281; napisa&#263; funkcje <TT>nwd a b</TT> oraz <TT>nww a =
b</TT>, kt=F3rych=20
  warto&#347;ciami s&#261; najwi&#281;kszy wsp=F3lny dzielnik i =
najmniejsza wsp=F3lna=20
  wielokrotno&#347;&#263;. <BR><BR>
  <LI>Prosz&#281; napisa&#263; funkcj&#281; <TT>(new.&lt; x y)</TT>, =
<TT>(new.&gt; x y)</TT>,=20
  <TT>(new.=3D x y)</TT>, <TT>(new.&lt;=3D x y)</TT>, <TT>(new.&gt;=3D x =
y)</TT> oraz=20
  <TT>(new.&lt;&gt; x y)</TT>. Nale&#380;y z wbudowanych funkcji =
u&#380;ywa&#263; wy&#322;&#261;cznie=20
  funckcj&#281; <TT>&lt;</TT> (oraz predykaty oczywi&#347;cie). <BR><BR>
  <LI> Prosz&#281; napisa&#263; funkcj&#281; <TT>(same-values? p1 p2 x =
y)</TT>, kt=F3rej warto&#347;&#263;=20
  jest <TT>#t</TT>, je&#380;eli <TT>(p1 x y)</TT> i <TT>(p2 x y)</TT> =
maj&#261; t&#261; sam&#261;=20
  warto&#347;&#263; i <TT>#f</TT> w przecziwnym przypadku.=20
<PRE>Przyk&#322;ady: =3D=3D&gt; (same-values? =3D new.=3D 3 1)=0A=
           #t=0A=
           =3D=3D&gt; (same-values? &lt; &gt; 2 3)=0A=
           #f=0A=
</PRE>
  <LI> Prosz&#281; napisa&#263; funkcje <TT>(odd? n)</TT> oraz =
<TT>(even? n)</TT>, kt=F3re=20
  sprawdzaj&#261;, czy liczba naturalna <TT>n</TT> jest nieparzysta =
wzgl&#281;dnie=20
  parzysta. Nale&#380;y u&#380;ywa&#263; wy&#322;&#261;cznie funkcje =
<TT>#t</TT>, <TT>#f</TT>,=20
  <TT>zero?</TT> oraz "<TT>-1</TT>".<BR><BR>
  <LI> Prosz&#281; napisa&#263; rekurencyjn&#261; oraz iteracyn&#261; =
funkcj&#281; <TT>(fib n)</TT>,=20
  kt=F3ra obliczy <TT>n</TT>-t&#261; liczb&#281; Fibonacci. <BR><BR>
  <LI>Pot&#281;gowanie b^e mo&#380;na szybko wykona&#263; =
u&#380;ywaj&#261;c b^e =3D (b^(e/2))^2. Prosz&#281;=20
  napisa&#263; rekurencyjn&#261; oraz iteracyjn&#261; funkcj&#281; =
<TT>(exp b e)</TT> na podstawie=20
  tej w&#322;a&#347;ciwo&#347;ci. U&#380;ywaj&#261;c model =
&#347;rodowiska, prosz&#281; pokazywa&#263;, jak wyra&#380;enie=20
  <TT>(exp 2 6)</TT> zostaje ewaluowane. <BR><BR>
  <LI> Niech b&#281;d&#261; dane nast&#281;puj&#261;ce definicje =
funkcji.=20
<PRE>(define m 1)             (define n 1)=0A=
(define (p m)            (define (q n)=0A=
   (pp 5))                  (define (qq x)=0A=
(define (pp x)                 (+ x n))=0A=
   (+ x m))                 (qq 5))=0A=
</PRE>=20
  Jakie s&#261; warto&#347;ci wyrazie&#324; <TT>(p 11)</TT> i <TT>(q =
11)</TT>?  Prosz&#281;=20
  wyt&#322;umaczy&#263; wyniki u&#380;ywaj&#261;c model &#347;rodowiska. =
<BR><BR>
  <LI> Prosz&#281; napisa&#263; funkcj&#281; <TT>(product term a next =
b)</TT> analogicznie do=20
  funkcji <TT>sum</TT> z wyk&#322;adu. Prosz&#281; pokazywa&#263;, jak =
u&#380;ywaj&#261;c <TT>=20
  product</TT> mo&#380;na definiowa&#263; funkcj&#281; <TT>silnia</TT> =
oraz przybli&#380;a&#263; <FONT=20
  face=3D"Symbol" size=3D"2">p</FONT> na podstawie formu&#322;y &nbsp;   =
<FONT face=3D"Symbol"=20
  size=3D"2">p</FONT>/4 =3D 2 =B7 4 =B7 4 =B7 6 =B7 6 =B7 8 =B7=B7=B7 / =
3 =B7 3 =B7 5 =B7 5 =B7 7 =B7 7 =B7=B7=B7 .=20
  <BR><BR>
  <LI> Prosz&#281; napisa&#263; funkcj&#281; <TT>(accumulate combiner =
null-value term a next=20
  b)</TT>, kt=F3ra jest uog=F3lnieniem funkcji <TT>sum</TT> i =
<TT>prod</TT>.
   Argumenty <TT>term</TT>, <TT>next</TT>, <TT>a</TT> i <TT>b</TT> =
zachowuj&#261; to=20
  same znaczenie ni&#380; w funkcjach <TT>sum</TT> i <TT>prod</TT>.  =20
  <TT>combiner</TT> jest dwuargumentow&#261; funkcj&#261;, kt=F3ra =
opisuja, jak <TT>(term=20
  a)</TT> zostaje dodane do akkumulacji dalszych term=F3w.  =
<TT>null-value</TT>=20
  jest warto&#347;ci&#261; inicjaln&#261; do u&#380;ywania w =
ko&#324;cowym przypadku. <BR>Prosz&#281;=20
  pokazywa&#263;, jak mo&#380;na definiowa&#263; funkcje <TT>sum</TT> i =
<TT>prod</TT> u&#380;ywaj&#261;c=20
  <TT>accumulate</TT>. <BR><BR>
  <LI> Nawet funkcj&#281; <TT>accumulate</TT> mo&#380;na dalej =
uog=F3lni&#263;. Prosz&#281; napisa&#263;=20
  funkcj&#281; <TT>filter-accumulate</TT>, kt=F3ra ma dodatkowy argument =
<TT>pred</TT>.=20
   <TT>pred</TT> jest (jednoargumentowym) predykatem a=20
  <TT>filter-accumulate</TT> dodaje <TT>(term a)</TT> do wynika tylko, =
je&#380;eli=20
  <TT>a</TT> spe&#322;nie predykat <TT>pred</TT>.  =
<BR>U&#380;ywaj&#261;c=20
  <TT>filter-accumulate</TT> prosz&#281; obliczy&#263; sum&#281; =
kwadrat=F3w liczb pierwszych w=20
  interwale [<TT>a</TT>,<TT>b</TT>] oraz produkt wszystkich liczb =
naturalnych=20
  <TT>i</TT> mniejsze ni&#380; <TT>n</TT>, takie &#380;e <TT> nwd(i,n) =
=3D 1</TT>. <BR><BR>
  <LI> Niech b&#281;dzie dana nast&#281;puj&#261;ca definicja funkcji =
<TT>(comb f g)</TT>.=20
<PRE>(define (comb f g)=0A=
   (lambda (x) (f (g x))))=0A=
</PRE>U&#380;ywaj&#261;c model=20
  &#347;dowiska, prosz&#281; pokazywa&#263; jak wyra&#380;enie =
<TT>((comb square double) 5)</TT>=20
  zostajy ewaluowane. <BR><BR>
  <LI> Prosz&#281; napisa&#263; funkcj&#281; <TT>(deriv f dx)</TT>, =
kt=F3r&#261; warto&#347;&#263; jest funkcj&#261;,=20
  kt=F3ra przybli&#380;a funkcj&#281; <TT>f'</TT> u&#380;ywaj&#261;c =
formu&#322;&#281;=20
<PRE> Df(x) =3D (f(x+dx) - f(x)) / dx.=0A=
</PRE>
<PRE>Przyk&#322;ad:  =3D=3D&gt; ((derive cube .001) 5)=0A=
           75.015=0A=
</PRE>
  <LI> Prosz&#281; napisa&#263; nast&#281;puj&#261;ce funkcje dla list: =
<BR><BR>a) <TT>(append l=20
  m)</TT>, kt=F3ra konkatenuje listy <TT>l</TT> i <TT>m</TT>.<BR><BR>b)=20
  <TT>(reverse l)</TT>, kt=F3ra obr=F3ci list&#281; =
<TT>l</TT>.<BR><BR>c) <TT>(last=20
  l)</TT>, kt=F3ra znajduje ostatni element w liscie =
<TT>l</TT>.<BR><BR>d)=20
  <TT>(delete x l)</TT>, kt=F3ra skasuje element <TT>x</TT> z listy=20
  <TT>l</TT>.<BR><BR>
  <LI> a) Prosz&#281; napisa&#263; funkcj&#281; <TT>(square-list =
l)</TT>, kt=F3rej warto&#347;&#263; jest=20
  list&#261; kwadrat=F3w element=F3w listy <TT>l</TT>. <BR><BR>b) =
Prosz&#281; napisa&#263; funkcj&#281;=20
  <TT>(mapf f l)</TT>, kt=F3rej warto&#347;ci&#261; jest lista =
warto&#347;ci <TT>f(e)</TT> dla=20
  wszystkich element=F3w <TT>e</TT> w liscie <TT>l</TT>. <BR><BR>
  <LI>  Prosz&#281; zdefiniowa&#263; funkcj&#281; <TT>(iter f n)</TT>, =
kt=F3rej warto&#347;ci&#261; jest=20
  funkcja <TT>f<SUP>n</SUP></TT>. <BR><BR>
  <LI> U&#380;ywaj&#261;c funkcj&#281; <TT>fold</TT> prosz&#281; =
zdefiniowa&#263; funkcje <BR><BR>     a)=20
  <TT>(prod l)</TT><BR><BR>     b) <TT>(length l)</TT><BR><BR>     c)=20
  <TT>(member x l)</TT><BR><BR>     c) <TT>(delete l)</TT> <BR><BR>     =
d)=20
  <TT>(reverse l)</TT><BR><BR><!--=0A=
<li> Prosz&#x0119; zdefiniowa&#263; funkcj&#x0119; <tt>search</tt>, =
kt&#x00F3;ra znajduje punkt zerowy danej funkcji <tt>f</tt>. <br><br>=0A=
-->=20
  <LI> Prosz&#281; zdefiniowa&#263; arytmetyk&#281; liczb wymiernich na =
podstawie liczb=20
  ca&#322;kowitych. <BR><BR>
  <LI> Obiekty nie b&#281;d&#261;ce parami nazywaj&#261; si&#281; atomy. =
Prosz&#281; napisa&#263; funkcj&#281;,=20
  kt=F3ra <BR><BR>a) sprawdza, czy w liscie <TT>l</TT> znajduj&#261; =
si&#281; wy&#322;&#261;cznie=20
  atomy. <BR><BR>b) obliczy, ile jest atom=F3w w liscie =
<TT>l</TT>.<BR><BR>
  <LI> Prosz&#281; napisa&#263; funkcj&#281; <TT>(member2 x l)</TT>, =
kt=F3 sprawdza, czy gdzie&#347; w=20
  liscie <TT>l</TT> znajduje si&#281; <TT>x</TT>.=20
<PRE>Przyk&#322;ady: =3D=3D&gt; (member2 'a '(b (c a) b))=0A=
           #t=0A=
           =3D=3D&gt; (member2 '(a) '(b (c (a) d) e))=0A=
           #t=0A=
           =3D=3D&gt; (member2 '(a) '(b c a))=0A=
           #f=0A=
</PRE>
  <LI> Prosz&#281; powi&#281;ksza&#263; funkcj&#281; <TT>deriv</TT> tak, =
&#380;eby te&#380; mog&#322;a traktowa&#263;=20
  termy typu <TT>u^n</TT> (na podstawie <TT> d(u^n) / dx =3D n * u^(n-1) =
* du / dx=20
  </TT>). <BR><BR>
  <LI> Prosz&#281; implementowa&#263; arytmetyk&#281; liczb zespolonych =
<BR><BR>a) u&#380;ywaj&#261;c=20
  metod&#281; "manifest types". <BR><BR>b) u&#380;ywaj&#261;c =
metod&#281; "message passing".=20
<BR><BR>
  <LI> W <TT>Scheme</TT> te&#380; mo&#380;na pisa&#263; funkcje z =
dowoln&#261; ilo&#347;ci&#261; argument=F3w:=20
<PRE> (define (f x y z . l) (...))=0A=
</PRE>oznacza, &#380;e funkcja <TT> f </TT> ma=20
  conajmniej trzy argumenty (<TT>x</TT>,<TT>y</TT> i <TT> z</TT>). =
Je&#380;eli <TT> f=20
  </TT> dostaje wi&#281;cej ni&#380; trzy  argumenty, dodatkowe =
argumenty zostaj&#261; zapisane=20
  do listy <TT> l </TT>. <BR><BR> a)  Prosz&#281; napisa&#263; =
funkcj&#281; <TT>plus</TT>,=20
  kt=F3ra podsumuje dowoln&#261; ilo&#347;&#263; liczb.<BR><BR> b) =
Prosz&#281; napisa&#263; funkcj&#281;=20
  <TT>par</TT> dla dowolniej ilo&#347;ci (jednoargumentowych) funkcji =
f<SUB>i</SUB>.=20
  Warto&#347;&#263; funkcji <TT>par</TT> jest (jednoargumentow&#261;) =
funkcj&#261;, kt=F3ra dla=20
  argumenta <TT>x</TT> obliczy list&#281; wszystkich=20
  <BR>&nbsp;&nbsp;&nbsp;&nbsp;warto&#347;ci <TT>f<SUB>i</SUB>(x)</TT>. =20
<PRE>&nbsp;&nbsp;Przyk&#322;ady: =3D=3D&gt; ((par id square cube) 3)=0A=
             (3 9 27) =0A=
             =3D=3D&gt; ((par double double) 5)=0A=
             (10 10)=0A=
</PRE>
  <LI> Dlaczego wyra&#380;enie <TT>if</TT> nie mo&#380;na sam =
definiowa&#263; w nast&#281;puj&#261;cy=20
  spos=F3b?=20
<PRE>(define (new-if warunek alternatywa1 alternatywa2)=0A=
   (cond (warunek alternatywa1)=0A=
         (else    alternatywa2)))=0A=
</PRE>
  <LI> Prosz&#281; napisa&#263; funkcj&#281; <TT>(ewal wyra&#380;enie =
warto&#347;ci)</TT>, kt=F3ra oblicy=20
  wynik dla wyra&#380;e&#324; boolowskich. <TT> wyra&#380;enie </TT> =
jest list&#261;, kt=F3rej=20
  pierwszym elementem jest "typ" wyra&#380;enia, a =
nast&#281;pne<BR>elementy tej listy, to=20
  podwyra&#380;enia; na przyk&#322;ad lista <TT>'(and x (not y))</TT> =
reprezentuje=20
  wyra&#380;enie <TT>x&#8743;=ACy</TT>. <TT> warto&#347;ci</TT> jest =
list&#261;, w kt=F3rej znaduj&#261; si&#281;=20
  warto&#347;ci zmiennych.=20
<PRE>Przyk&#322;ady: =3D=3D&gt; (define w '((x . #f) (y . #t) (z . #f)))=0A=
           w=0A=
           =3D=3D&gt; (ewal '(and y (not x)) w)=0A=
           #t=0A=
           =3D=3D&gt; (ewal '(and y (and (not x) z))) w)=0A=
           #f=0A=
           =3D=3D&gt; (ewal '(and y 1) w)=0A=
           #t=0A=
</PRE>
  <LI> Niech <TT> a<SUB>1</SUB></TT>,  <TT>a<SUB>2</SUB></TT>, ... =
b&#281;d&#261;=20
  wyra&#380;enami. Regu&#322;a jest dana w formie=20
  <TT>{a<SUB>i<SUB>1</SUB></SUB>,...a<SUB>i<SUB>n</SUB></SUB>} &#8594;=20
  a<SUB>i</SUB></TT>.  Regu&#322;a jest faktem, je&#380;eli <TT>n</TT> =
=3D 0. <BR> Niech=20
  <TT>R</TT> b&#281;dzie zbiorem regu&#322;. Wyra&#380;enie <TT>a</TT> =
jest prawdziwe w=20
  <TT>R</TT>, je&#380;eli <BR><BR>(i) <TT>a</TT> jest faktem lub =
<BR><BR>(ii)=20
  istnieje regu&#322;a =
<TT>{a<SUB>i<SUB>1</SUB></SUB>,...a<SUB>i<SUB>n</SUB></SUB>} &#8594;=20
  a<SUB>i</SUB></TT> w <TT>R</TT>, taka &#380;e <TT>a<SUB>i</SUB></TT> =
=3D <TT>a</TT>=20
  oraz <TT>a<SUB>i<SUB>1</SUB></SUB></TT>,... =
<TT>a<SUB>i<SUB>n</SUB></SUB></TT>=20
  s&#261; prawdziwe w <TT>R</TT>.<BR><BR>Prosz&#281; napisa&#263; =
funkcj&#281; <TT>(valid a R)</TT>,=20
  kt=F3ra sprawdza, czy wyra&#380;enie <TT>a</TT> jest prawdziwe w =
<TT>R</TT>. Prosz&#281;=20
  u&#380;y&#263; przy tym reprezentacje <TT>(fact a<SUB>i</SUB>)</TT> =
dla faktu oraz=20
  <TT>(rule (a<SUB>i<SUB>1</SUB></SUB> ... a<SUB>i<SUB>n</SUB></SUB>)=20
  a<SUB>i</SUB>)</TT> <BR>dla regu&#322;y=20
  <TT>{a<SUB>i<SUB>1</SUB></SUB>,...a<SUB>i<SUB>n</SUB></SUB>} &#8594;=20
  a<SUB>i</SUB></TT>. =20
<PRE> Przyk&#322;ad:=0A=
 =3D=3D&gt; (define R '((fact a<SUB>1</SUB>)=0A=
                 (rule (a<SUB>1</SUB>) a<SUB>2</SUB>)=0A=
                 (rule (a<SUB>1</SUB> a<SUB>5</SUB>) a<SUB>3</SUB>)=0A=
                 (rule (a<SUB>2</SUB>) a<SUB>5</SUB>)=0A=
                 (rule (a<SUB>2</SUB> a<SUB>6</SUB>) a<SUB>4</SUB>)))=0A=
 R=0A=
 =3D=3D&gt; (valid 'a1 R)=0A=
 #t=0A=
 =3D=3D&gt; (valid 'a3 R)=0A=
 #t=0A=
 =3D=3D&gt; (valid 'a4 R)=0A=
 #f =0A=
</PRE><!-- =0A=
<li> a) Niech b&#x0119;d&#x0105; dane nast&#x0119;puj&#x0105;ce =
definicje.=0A=
<pre> (define litery '(a b c))=0A=
  (define liczbe '(1 2 3))=0A=
</pre>=0A=
&#160;&#160;&#160;&#160;Jaka jest warto&#x015B;&#x0107; wyra&#x017C;enia =
<tt> (append litery liczby)</tt>, a jakie warto&#x015B;ci maj&#x0105; =
potem <tt> litery </tt> i <tt>liczby</tt>? <br>=0A=
&#160;&#160;&#160;&#160;Jaka jest warto&#x015B;&#x0107; wyra&#x017C;enia =
<tt> (append! litery liczby)</tt>, a jakie warto&#x015B;ci maj&#x0105; =
potem <tt> litery </tt> i <tt>liczby</tt>? <br><br>=0A=
b) Prosz&#x0119; narysowa&#x0107; diagramy dla warto&#x015B;ci =
<tt>litery</tt> oraz <tt>litery-litery</tt> po wykonywaniu =0A=
<pre> (define litery '(a b c))=0A=
 (define litery-litery (append! litery literty))=0A=
</pre>=0A=
&#160;&#160;&#160;&#160;Co si&#x0119; sta&#x0142;o, je&#x017C;eli teraz =
wyra&#x017C;enie <tt>(append! litery '())</tt> zostaje =
wykonywane?<br><br>=0A=
c) Niech b&#x0119;d&#x0105; dane nast&#x0119;puj&#x0105;ce definicje.=0A=
<pre> (define (test  z) (append '(test wykonywane z) (list z)))=0A=
 (define (test! z) (append! '(test wykonywane z) (list z)))=0A=
</pre>=0A=
&#160;&#160;&#160;&#160;Jakie s&#x0105; warto&#x015B;ci =
wyra&#x017C;e&#x0144;=0A=
<tt>(test 1)</tt>, <tt>(test 2)</tt> i <tt>(test 3)</tt> wykonywane w =
tej kolejno&#x015B;ci? =0A=
<br>&#160;&#160;&#160;&#160;Jakie s&#x0105; warto&#x015B;ci =
wyra&#x017C;e&#x0144;=0A=
<tt>(test! 1)</tt>, <tt>(test! 2)</tt> i <tt>(test! 3)</tt> wykonywane w =
tej kolejno&#x015B;ci?=0A=
<br><br>=0A=
-->=20
  </LI></OL></BODY></HTML>
